\hypertarget{classhwlib_1_1bufferwindow}{\section{hwlib\+:\+:bufferwindow Class Reference}
\label{classhwlib_1_1bufferwindow}\index{hwlib\+::bufferwindow@{hwlib\+::bufferwindow}}
}


the main class of dubblebufferd, a decorator for hwlib windows.  




{\ttfamily \#include $<$hwlib-\/dubblebufferd.\+hpp$>$}



Inheritance diagram for hwlib\+:\+:bufferwindow\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=183pt]{classhwlib_1_1bufferwindow__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for hwlib\+:\+:bufferwindow\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=183pt]{classhwlib_1_1bufferwindow__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classhwlib_1_1bufferwindow_ab7b3cae85b441cfc9123201b30b86dae}{bufferwindow} (window \&slave\+Window)
\begin{DoxyCompactList}\small\item\em The decorator of a buffered window. \end{DoxyCompactList}\item 
\hypertarget{classhwlib_1_1bufferwindow_abfe7d7caa932892ca025d1dab49b13d4}{virtual void {\bfseries clear} ()}\label{classhwlib_1_1bufferwindow_abfe7d7caa932892ca025d1dab49b13d4}

\item 
\hypertarget{classhwlib_1_1bufferwindow_aa25f7a689ad5328e457c963b7a348d81}{void {\bfseries flush} ()}\label{classhwlib_1_1bufferwindow_aa25f7a689ad5328e457c963b7a348d81}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
the main class of dubblebufferd, a decorator for hwlib windows. 

This class implements an decorator to any$\ast$ hwlib window, it adds the functionallity of dubble buffering for windows that take a very long time to clear and rewrite completly each frame, such as S\+S\+D1306 controlled screens. right now I only support the S\+S\+D1306 Glcd-\/\+Oled window because that is \#1 priority

It uses an array of bools instead of working with bitwise operators because the memory loss outweighed the performance increase, plus it was way easier to make in my available time.

Usage\+: The only thing you need to change in your code is add a .flush() command every time you want to update the screen 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classhwlib_1_1bufferwindow_ab7b3cae85b441cfc9123201b30b86dae}{\index{hwlib\+::bufferwindow@{hwlib\+::bufferwindow}!bufferwindow@{bufferwindow}}
\index{bufferwindow@{bufferwindow}!hwlib\+::bufferwindow@{hwlib\+::bufferwindow}}
\subsubsection[{bufferwindow}]{\setlength{\rightskip}{0pt plus 5cm}hwlib\+::bufferwindow\+::bufferwindow (
\begin{DoxyParamCaption}
\item[{window \&}]{slave\+Window}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classhwlib_1_1bufferwindow_ab7b3cae85b441cfc9123201b30b86dae}


The decorator of a buffered window. 


\begin{DoxyParams}{Parameters}
{\em slave\+Window} & slave\+Window is a reference to any hwlib window. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Arduino\+\_\+implementation/\+Lib/\+Dubblebufferlib/\hyperlink{hwlib-dubblebufferd_8hpp}{hwlib-\/dubblebufferd.\+hpp}\end{DoxyCompactItemize}
